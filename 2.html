<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>åƒè±†äºº V2.0 - æ™ºèƒ½å¹½çµç‰ˆ</title>
    <style>
        body {
            background-color: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        h2 { margin: 10px 0; text-shadow: 0 0 10px #ffff00; }
        .info { margin-bottom: 10px; color: #ccc; font-size: 14px; }
        
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        
        canvas {
            background-color: black;
            border: 4px solid #2c3e50;
            border-radius: 4px;
            display: block;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            display: none;
            z-index: 10;
        }
        #overlay h1 { font-size: 40px; margin: 0 0 20px 0; }
        #overlay button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background: #f1c40f;
            border: none;
            border-radius: 5px;
            font-weight: bold;
        }
        #overlay button:hover { background: #d4ac0d; }
    </style>
</head>
<body>

    <h2>ğŸŸ¡ åƒè±†äºº V2.0 (æ™ºèƒ½ç‰ˆ)</h2>
    <div class="info">
        åˆ†æ•°: <span id="scoreEl" style="color:yellow; font-weight:bold;">0</span> 
        | <span style="color:#ff4444">çº¢é¬¼ä¼šè¿½ä½ </span> | <b>æ–¹å‘é”®</b> ç§»åŠ¨
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="overlay">
            <h1 id="statusText">æ¸¸æˆç»“æŸ</h1>
            <button onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreEl');
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('statusText');

        // --- 1. æ¸¸æˆé…ç½® ---
        const TILE_SIZE = 20; 
        const ROWS = 20;
        const COLS = 20;
        const SPEED = 2; // å¿…é¡»èƒ½è¢« TILE_SIZE æ•´é™¤

        // 1=å¢™, 0=è±†å­, 2=ç©ºåœ°, 9=åƒè±†äºº, 8=å¹½çµå‡ºç”Ÿç‚¹
        const rawMap = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,1],
            [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,2,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,1,2,2,2,1,0,1,0,0,0,0,0,1],
            [1,1,1,1,0,1,0,1,2,8,2,1,0,1,0,1,1,1,1],
            [1,2,2,1,0,1,0,1,1,2,1,1,0,1,0,1,2,2,1], // è¿™é‡Œçš„2æ˜¯åœ°å›¾å¤–çš„è£…é¥°æˆ–ç©ºåœ°
            [1,1,1,1,0,1,0,2,2,8,2,2,0,1,0,1,1,1,1], // ä¸­é—´ç¨å¾®å®½æ•ä¸€ç‚¹ç»™é¬¼
            [1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1,0,9,0,1,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1],
            [1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let walls = [];
        let pellets = [];
        let score = 0;
        let gameRunning = false;
        let animationId;
        let mouthOpen = 0; 
        let mouthSpeed = 0.15; 

        // è§’è‰²å¯¹è±¡ (åæ ‡ä¸ºå·¦ä¸Šè§’)
        const pacman = { x:0, y:0, vx:0, vy:0, nextVx:0, nextVy:0, rotation:0 };
        const ghosts = [];

        // --- 2. å·¥å…·å‡½æ•° ---
        
        // åˆ¤æ–­æŸä¸ªç½‘æ ¼åæ ‡æ˜¯å¦æ˜¯å¢™å£
        function isWall(col, row) {
            // è¾¹ç•Œæ£€æŸ¥
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return true;
            // åœ¨ rawMap ä¸­ï¼Œ1 æ˜¯å¢™
            return rawMap[row][col] === 1;
        }

        // è·å–è§’è‰²å½“å‰æ‰€åœ¨çš„ç½‘æ ¼åæ ‡
        function getGridPos(actor) {
            return {
                col: Math.round(actor.x / TILE_SIZE),
                row: Math.round(actor.y / TILE_SIZE)
            };
        }

        // --- 3. åˆå§‹åŒ– ---

        function initGame() {
            score = 0;
            scoreEl.innerText = score;
            walls = [];
            pellets = [];
            ghosts.length = 0;

            // è§£æåœ°å›¾
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const val = rawMap[r][c];
                    const posX = c * TILE_SIZE;
                    const posY = r * TILE_SIZE;

                    if (val === 1) {
                        walls.push({ x: posX, y: posY });
                    } else if (val === 0) {
                        pellets.push({ x: posX + TILE_SIZE/2, y: posY + TILE_SIZE/2 });
                    } else if (val === 9) {
                        pacman.x = posX; pacman.y = posY;
                        pacman.vx = 0; pacman.vy = 0;
                        pacman.nextVx = 0; pacman.nextVy = 0;
                        pacman.rotation = 0;
                    } else if (val === 8) {
                        // æ”¶é›†å‡ºç”Ÿç‚¹ï¼Œç¨ååˆ†é…ç»™é¬¼
                    }
                }
            }

            // åˆå§‹åŒ–ä¸‰ä¸ªå¹½çµ
            // çº¢è‰²ï¼šè¿½å‡»è€…
            ghosts.push(createGhost(9, 7, 'red', 'chaser'));
            // ç²‰è‰²ï¼šéšæœºæ¸¸è¡
            ghosts.push(createGhost(9, 9, 'pink', 'random')); 
            // é’è‰²ï¼šéšæœºæ¸¸è¡
            ghosts.push(createGhost(10, 9, 'cyan', 'random'));

            gameRunning = true;
            overlay.style.display = 'none';
            animate();
        }

        function createGhost(col, row, color, type) {
            return {
                x: col * TILE_SIZE,
                y: row * TILE_SIZE,
                vx: 0,
                vy: 0,
                color: color,
                type: type,
                speed: SPEED
            };
        }

        // --- 4. æ§åˆ¶ ---
        window.addEventListener('keydown', (e) => {
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                e.preventDefault(); // é˜²æ­¢æ»šåŠ¨é¡µé¢
            }
            switch(e.key) {
                case 'ArrowUp':    pacman.nextVx = 0; pacman.nextVy = -SPEED; break;
                case 'ArrowDown':  pacman.nextVx = 0; pacman.nextVy = SPEED; break;
                case 'ArrowLeft':  pacman.nextVx = -SPEED; pacman.nextVy = 0; break;
                case 'ArrowRight': pacman.nextVx = SPEED; pacman.nextVy = 0; break;
            }
        });

        // --- 5. æ¸¸æˆä¸»å¾ªç¯ ---
        function animate() {
            if (!gameRunning) return;
            animationId = requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- ç»˜åˆ¶å¢™å£ ---
            ctx.fillStyle = '#1919A6';
            walls.forEach(w => ctx.fillRect(w.x, w.y, TILE_SIZE, TILE_SIZE));

            // --- ç»˜åˆ¶è±†å­ ---
            ctx.fillStyle = '#feb';
            pellets.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
            });

            // --- åƒè±†äººé€»è¾‘ ---
            movePacman();
            drawPacman();

            // --- å¹½çµé€»è¾‘ ---
            ghosts.forEach(g => {
                moveGhost(g);
                drawGhost(g);
                
                // ç¢°æ’æ£€æµ‹ (è·ç¦»åˆ¤æ–­)
                const dist = Math.hypot((g.x - pacman.x), (g.y - pacman.y));
                if (dist < TILE_SIZE - 5) {
                    gameOver(false);
                }
            });

            // åƒè±†å­
            // ç®€å•ç¢°æ’ï¼šå½“ Pacman ä¸­å¿ƒç‚¹æ¥è¿‘è±†å­ä¸­å¿ƒç‚¹
            const pacCx = pacman.x + TILE_SIZE/2;
            const pacCy = pacman.y + TILE_SIZE/2;
            for (let i = pellets.length - 1; i >= 0; i--) {
                const p = pellets[i];
                const dist = Math.hypot(p.x - pacCx, p.y - pacCy);
                if (dist < 8) { // åƒåˆ°è±†å­
                    pellets.splice(i, 1);
                    score += 10;
                    scoreEl.innerText = score;
                }
            }

            if (pellets.length === 0) gameOver(true);
        }

        // --- 6. ç§»åŠ¨é€»è¾‘ (æ ¸å¿ƒæ”¹è¿›) ---

        function movePacman() {
            // åªæœ‰åœ¨å®Œå…¨å¯¹é½ç½‘æ ¼æ—¶ï¼Œæ‰å…è®¸æ”¹å˜æ–¹å‘
            // è¿™æ ·å¯ä»¥é˜²æ­¢â€œå¡å¢™â€
            if (pacman.x % TILE_SIZE === 0 && pacman.y % TILE_SIZE === 0) {
                const col = pacman.x / TILE_SIZE;
                const row = pacman.y / TILE_SIZE;

                // æ£€æŸ¥"é¢„é€‰æ–¹å‘"æ˜¯å¦å¯è¡Œ
                let nextCol = col;
                let nextRow = row;
                if (pacman.nextVx > 0) nextCol++;
                if (pacman.nextVx < 0) nextCol--;
                if (pacman.nextVy > 0) nextRow++;
                if (pacman.nextVy < 0) nextRow--;

                if (!isWall(nextCol, nextRow)) {
                    pacman.vx = pacman.nextVx;
                    pacman.vy = pacman.nextVy;
                    // æ›´æ–°æ—‹è½¬è§’åº¦
                    if(pacman.vx > 0) pacman.rotation = 0;
                    if(pacman.vx < 0) pacman.rotation = Math.PI;
                    if(pacman.vy < 0) pacman.rotation = -Math.PI/2;
                    if(pacman.vy > 0) pacman.rotation = Math.PI/2;
                } 
                
                // æ£€æŸ¥"å½“å‰æ–¹å‘"å‰æ–¹æ˜¯å¦æœ‰å¢™ï¼ˆå¦‚æœæ˜¯ï¼Œåœæ­¢ç§»åŠ¨ï¼‰
                nextCol = col;
                nextRow = row;
                if (pacman.vx > 0) nextCol++;
                if (pacman.vx < 0) nextCol--;
                if (pacman.vy > 0) nextRow++;
                if (pacman.vy < 0) nextRow--;

                if (isWall(nextCol, nextRow)) {
                    pacman.vx = 0;
                    pacman.vy = 0;
                }
            }

            pacman.x += pacman.vx;
            pacman.y += pacman.vy;
        }

        function moveGhost(ghost) {
            // å¹½çµ AI å†³ç­–ï¼šåªæœ‰åœ¨åˆšå¥½åˆ°è¾¾æ ¼å­ä¸­å¿ƒæ—¶æ‰åšå†³ç­–
            if (ghost.x % TILE_SIZE === 0 && ghost.y % TILE_SIZE === 0) {
                const col = ghost.x / TILE_SIZE;
                const row = ghost.y / TILE_SIZE;

                // 1. æ‰¾å‡ºæ‰€æœ‰å¯è¡Œçš„æ–¹å‘
                const directions = [
                    { vx: 0, vy: -SPEED, name: 'UP' },
                    { vx: 0, vy: SPEED, name: 'DOWN' },
                    { vx: -SPEED, vy: 0, name: 'LEFT' },
                    { vx: SPEED, vy: 0, name: 'RIGHT' }
                ];

                const validMoves = directions.filter(dir => {
                    // ä¸èµ°å¢™å£
                    const nextC = col + (dir.vx / SPEED);
                    const nextR = row + (dir.vy / SPEED);
                    if (isWall(nextC, nextR)) return false;

                    // å°½é‡ä¸èµ°å›å¤´è·¯ (é™¤éæ˜¯æ­»èƒ¡åŒ)
                    // å¦‚æœå½“å‰æœ‰é€Ÿåº¦ï¼Œä¸”è¿™ä¸ªæ–°æ–¹å‘æ˜¯åæ–¹å‘ï¼Œå…ˆæ ‡è®°
                    if (ghost.vx !== 0 || ghost.vy !== 0) {
                        if (dir.vx === -ghost.vx && dir.vy === -ghost.vy) {
                            // åªæœ‰åœ¨æ²¡æœ‰å…¶ä»–è·¯å¯é€‰æ—¶ï¼Œæ‰å…è®¸å›å¤´
                            // æˆ‘ä»¬ç¨åå¤„ç†ï¼Œè¿™é‡Œå…ˆæš‚æ—¶å…è®¸ï¼Œä½†åœ¨é€‰æ‹©é€»è¾‘é‡Œé™ä½ä¼˜å…ˆçº§
                            return true; 
                        }
                    }
                    return true;
                });

                // å¦‚æœæ²¡æœ‰è·¯èµ°ï¼ˆåº”è¯¥ä¸ä¼šå‘ç”Ÿï¼Œé™¤éå¡æ­»ï¼‰ï¼Œå°±åœä¸‹
                if (validMoves.length === 0) return;

                // å‰”é™¤å›å¤´è·¯ (å¦‚æœæœ‰å¤šäº1æ¡è·¯å¯é€‰)
                let bestMoves = validMoves;
                if (validMoves.length > 1 && (ghost.vx !== 0 || ghost.vy !== 0)) {
                    bestMoves = validMoves.filter(dir => !(dir.vx === -ghost.vx && dir.vy === -ghost.vy));
                }

                // 2. æ ¹æ®æ€§æ ¼é€‰æ‹©æ–¹å‘
                let chosenDir;

                if (ghost.type === 'chaser') {
                    // [çº¢è‰²å¹½çµ]ï¼šé€‰æ‹©ç¦»åƒè±†äººæœ€è¿‘çš„é‚£ä¸ªæ ¼å­
                    // è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å¯»è·¯ç®—æ³•
                    let minDistance = 999999;
                    bestMoves.forEach(move => {
                        const targetCol = col + (move.vx / SPEED);
                        const targetRow = row + (move.vy / SPEED);
                        
                        // è®¡ç®—åˆ° Pacman çš„è·ç¦»
                        const pacCol = Math.round(pacman.x / TILE_SIZE);
                        const pacRow = Math.round(pacman.y / TILE_SIZE);
                        
                        // ä½¿ç”¨å‹¾è‚¡å®šç†è®¡ç®—è·ç¦»
                        const dist = Math.pow(targetCol - pacCol, 2) + Math.pow(targetRow - pacRow, 2);
                        
                        if (dist < minDistance) {
                            minDistance = dist;
                            chosenDir = move;
                        }
                    });
                } else {
                    // [éšæœºå¹½çµ]ï¼šä»å¯è¡Œè·¯å¾„é‡Œéšæœºé€‰ä¸€æ¡
                    chosenDir = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }

                // åº”ç”¨é€‰æ‹©
                if (chosenDir) {
                    ghost.vx = chosenDir.vx;
                    ghost.vy = chosenDir.vy;
                }
            }

            ghost.x += ghost.vx;
            ghost.y += ghost.vy;
        }

        function drawPacman() {
            ctx.save();
            // ç§»åŠ¨ç”»å¸ƒåŸç‚¹åˆ°åƒè±†äººä¸­å¿ƒï¼Œæ–¹ä¾¿æ—‹è½¬
            ctx.translate(pacman.x + TILE_SIZE/2, pacman.y + TILE_SIZE/2);
            ctx.rotate(pacman.rotation);
            
            // å˜´å·´åŠ¨ç”»
            if (mouthOpen > 0.5 || mouthOpen < 0) mouthSpeed = -mouthSpeed;
            mouthOpen += mouthSpeed * 0.5;
            const currentMouth = (pacman.vx===0 && pacman.vy===0) ? 0.2 : Math.abs(mouthOpen);

            ctx.beginPath();
            ctx.arc(0, 0, 9, currentMouth, Math.PI * 2 - currentMouth);
            ctx.lineTo(0, 0);
            ctx.fillStyle = '#ffe135';
            ctx.fill();
            ctx.restore();
        }

        function drawGhost(g) {
            const cx = g.x + TILE_SIZE/2;
            const cy = g.y + TILE_SIZE/2;
            
            ctx.beginPath();
            // å¤´éƒ¨åœ†å¼§
            ctx.arc(cx, cy - 2, 9, Math.PI, 0); 
            // åº•éƒ¨æ³¢æµªçº¿
            ctx.lineTo(cx + 9, cy + 9);
            ctx.lineTo(cx + 4, cy + 7);
            ctx.lineTo(cx - 4, cy + 9);
            ctx.lineTo(cx - 9, cy + 7);
            ctx.lineTo(cx - 9, cy);
            ctx.fillStyle = g.color;
            ctx.fill();
            
            // çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(cx - 4, cy - 2, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx + 4, cy - 2, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(cx - 4, cy - 2, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx + 4, cy - 2, 1.5, 0, Math.PI*2); ctx.fill();
        }

        function gameOver(win) {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            statusText.innerText = win ? "ğŸ‰ èƒœåˆ©ï¼" : "ğŸ’€ æ¸¸æˆç»“æŸ";
            statusText.style.color = win ? "#2ecc71" : "#e74c3c";
            overlay.style.display = 'flex';
        }

        function resetGame() {
            initGame();
        }

        initGame();

    </script>
</body>
</html>